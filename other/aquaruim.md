# Мини-проект "Аквариум"

Привет! Этот урок рассчитан на повторение материала и закрепление материала. <br>
Поставь галочку, если обещаешь, что будешь стараться!<br>

- [] Обещаю, что буду стараться :tada:
В чем суть проекта. Нужно будет сделать что-то вроде акварума с рыбками. Вот и все, вся идея. <br>
### Давай начинать<br>
Что мы знаем про рыб? Мы точно знаем, что в аквариуме они передвигаются хаотично, без особой системы. Просто плавают туда-сюда. <br>
<br>
<img src="https://media1.tenor.com/m/jTs8imWCZuwAAAAd/3d-gifs-artist-clownfish.gif">
<br>
Это путь к пониманию и видению нашего проекта. Нам нужно будет воссоздать аквариум и сделать хаотичное движение рыбам. <br>
> [!IMPORTANT]
> Важно этот проект делать по частям и вдумчиво, чтобы лучше вникнуть в детали.

### Создание проекта
Начнем мы с создания самого проекта в `Godot Engine`. 
> Если нет Godot Engine на компьютере, то скачать можно [отсюда](https://godotengine.org/download/windows/) или в Steam.<br>

Как открыли движок - нужно нажать на кнопку `Новый проект`<br>
<br>
<img src="https://github.com/mykweenn/byteschool/blob/main/other/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202024-02-04%20163951.png">
<br>
После этого необходимо дать имя файлу, выбрать папку (по желанию) и создать папку. После этого нажать кнопку `Создать и редактировать`<br>
<br>
<img src="https://github.com/mykweenn/byteschool/blob/main/other/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202024-02-04%20164216.png">

### Настройка проекта
Внутри самого проекта мы будем наблюдать следующее:
<img src="https://github.com/mykweenn/byteschool/blob/main/other/img/image.png">

Для дальнейшей настройки нужно выбрать сразу же параметры окна. <br>
Заходим в левом верхнем углу `Проект` -> `Настройки проекта` -> `Основное` -> `Дисплей` -> `Окно` <br>
И проставляем следующие настройки:
<br>
![image](https://github.com/mykweenn/byteschool/assets/98867083/8170f551-fc29-47bb-9498-79d7608416ba)
<br>
![image](https://github.com/mykweenn/byteschool/assets/98867083/3feaff25-ff62-4163-89d1-bef065ca4a24)
<br>
> [!TIP]
> Настройка `Default Texture Filter` необходима для выбора алгоритма отрисовки текстур (делает пиксели заметнее)<br>


Убеждаемся, что настройки совпадают и продолжаем работу. <br>
Игра у нас будет двухмерная (2D) и поэтому создать нужно будет 2D сцену <br>
![image](https://github.com/mykweenn/byteschool/assets/98867083/035d40da-94af-411a-9c74-2386b0f048c6)
<br>
Сразу же сохраним созданную сцену сочетанием клавиш `CTRL + S` и начнем загрузку [файлов](https://github.com/mykweenn/byteschool/tree/main/other/res/sprites) необходимых для проекта
> [!IMPORTANT]
> Вот прям точно надо скачать одну из текстур рыбы и фон. Фон называется `underwater-fantasy-preview.png`. А рыбу любую и сколько угодно.
<br>
Чтобы скачать файл нужно открыть его и нажать на кнопку скачивания в правом верхнем углу <br>

![image](https://github.com/mykweenn/byteschool/assets/98867083/49b13b25-2d44-494f-b3ad-58136eb45bb0)

Перетаскиваем фон на сцену и настраиваем эту картинку.

![image](https://github.com/mykweenn/byteschool/assets/98867083/648301d9-3095-4e60-aa58-22e639269993)

Сохраняем сцену.<br>

### Создание сцены с рыбой
Создать сцену можно несколькими способами:
- Через плюсик вверху
- `Сцена` -> `Новая сцена`
![image](https://github.com/mykweenn/byteschool/assets/98867083/e5fe7ce4-544e-46c8-a62c-31c46e9ddec7)

Далее, как создали сцену, необходимо выбрать узел.<br>
Жмем `Другой узел` и пишем в поисковике `CharacterBody2D`<br>
> Можно писать не полностью, здесь умный поисковик

Далее подключаем дочерние узлы к `CharacterBody2D`
> Жми ПКМ (правая кнопка мыши) на родительский узел `CharacterBody2D` и дальше кнопку `Добавить дочерний узел`. Подключи узлы, которые ты можешь увидеть на скрине.


Итог сцены с рыбой:<br>
![image](https://github.com/mykweenn/byteschool/assets/98867083/b8710cd0-eee7-4d0a-825b-4b78d062047d)

Прикрепляем скрипт<br>

>[!NOTE]
>С полным скриптом можно ознакомиться по этой [ссылке](https://gist.github.com/mykweenn/806f2841e97176408cedde04356cf06f)

В скрипте нам понадобятся следующие переменные:
``` gdscript
var screen_size 
var time_to_change_dir = 6
var timer = 0
var point = Vector2()
```
>[!Tip]
>Иногда можно понять смысл переменных или функций, если просто дословно их перевести!

Разберем для чего они вообще нужны? Отлично, погнали
- `var screen_size` - эта переменная будет у нас хранить в себе размер экрана
- `var time_to_change_dir = 6` - хранит в себе время для смены направления движения рыбки, время равняется 6
- `var timer = 0` - это просто таймер
- `var point = Vector2()` - это точка, до которой нужно будет дойти рыбе, эта точка генерируется случайно двумя векторами: X и Y

<br>

Далее мы напишем функцию для того, чтобы рыба могла начать шевелиться.

``` gdscript
func _process(delta):
  timer += delta
  time_to_change_dir = randi_range(2, 8)
  print(time_to_change_dir)
```
 **Давай разберем этот код построчно:**

1. `func _process(delta):` - Эта строка обозначает начало определения функции _process, которая автоматически вызывается каждый кадр игры (по умолчанию 60 раз в секунду). `delta` - это параметр, который представляет собой время, прошедшее с момента последнего кадра.

2. `timer += delta` - Эта строка увеличивает значение переменной timer на количество прошедшего времени с предыдущего кадра. Это обычно используется для отслеживания времени в игре.

3. `time_to_change_dir = randi_range(2, 8)` - Здесь мы создаем переменную `time_to_change_dir` и присваиваем ей случайное целое число в диапазоне от 2 до 8. Функция `randi_range(a, b)` генерирует случайное целое число включительно от a до b.

4. `print(time_to_change_dir)` - Этот код выводит значение переменной time_to_change_dir в консоль (терминал), чтобы мы могли видеть, какое случайное число было сгенерировано.

>[!Tip]
>Ты можешь открыть код по ссылке выше и сверяться оттуда
<br>

``` gdscript
  if timer >= time_to_change_dir:
    timer = 0
    point = Vector2(randf_range(0,screen_size.x), randf_range(0, screen_size.y))
  self.position = lerp(self.position, point, 0.002)
```
 **Давай разберем этот код построчно:**
1. `if timer >= time_to_change_dir:` - Эта строка представляет условный оператор if, который проверяет, если значение переменной timer больше или равно значению переменной `time_to_change_dir`.

2. `timer = 0` - Если условие в предыдущей строке выполняется (значение `timer` больше или равно `time_to_change_dir`), то переменная timer устанавливается обратно в 0. Это означает, что прошло достаточно времени для изменения направления.

3. `point = Vector2(randf_range(0, screen_size.x), randf_range(0, screen_size.y))` - Здесь мы создаем переменную point и присваиваем ей новый объект типа Vector2, который представляет собой случайные координаты в пределах экрана игры. Функция randf_range(a, b) генерирует случайное число с плавающей запятой в диапазоне от a до b.
4. `self.position = lerp(self.position, point, 0.002)` - Этот код использует функцию lerp (linear interpolation) для плавного перемещения объекта к новой точке point. 
  - `lerp(self.position, point, 0.002)` - Функция `lerp` принимает три параметра: начальную точку `(self.position)`, конечную точку `(point)` и фактор скорости перемещения (в данном случае 0.002). Она вычисляет промежуточную точку между начальной и конечной точками, чтобы объект двигался плавно к новой цели.
  - `self.position = lerp(...)` - Результат выполнения функции lerp присваивается обратно переменной `self.position`, что обновляет позицию объекта на экране.

Таким образом, эта строка кода обеспечивает плавное перемещение объекта к случайной точке point с постепенным приближением к этой цели.

<br>
Дальше мы разберем подробнее используемую формулу линейной интерполяции, вдруг если не совсем понятно как и зачем это нужно.<br>
Прости, но дальше будет чуточку душно.<br>
<br>

**Формула линейной интерполяции:**
``` math
    interp = (1 - t) ·start + t ·end
```

где:
- interp - результат интерполяции,
- t - коэффициент интерполяции в диапазоне [0, 1],
- start - начальное значение,
- end - конечное значение.

**Формула метода lerp() из Godot Engine:**
```
    lerp(start, end, t)
```

где:
- start - начальное значение,
- end - конечное значение,
- t - коэффициент интерполяции в диапазоне [0, 1].
<br>
Отличие между формулой линейной интерполяции и методом `lerp()` заключается в том, что метод `lerp()` является более удобным и компактным способом для выполнения линейной интерполяции в Godot Engine. Метод `lerp()` принимает начальное и конечное значения, а также коэффициент интерполяции t и возвращает результат интерполяции.<br>

<br>
<details>
<summary>Еще подробнее можно почитать здесь</summary>
<br>
Коэффициент интерполяции (t) играет ключевую роль в процессе линейной интерполяции. Он определяет, насколько близко мы находимся к конечному значению в результате интерполяции. Вот несколько причин, по которым коэффициент интерполяции важен:

1. Плавные анимации: Коэффициент интерполяции позволяет создавать плавные анимации и переходы между значениями. При изменении t от 0 до 1 значение результата изменяется плавно от начального к конечному.

2. Контроль скорости: Изменяя значение t, можно контролировать скорость изменения значения в процессе интерполяции. Например, при t = 0.5 изменение будет происходить на полпути между начальным и конечным значениями.

3. Адаптивность: Используя коэффициент интерполяции, можно легко адаптировать интерполяцию для различных задач и эффектов, варьируя скорость и стиль перехода между значениями.

4. Универсальность: Коэффициент интерполяции позволяет использовать одну и ту же формулу для интерполяции различных типов данных и значений, делая ее универсальной и применимой в различных ситуациях.

Таким образом, коэффициент интерполяции является важным параметром, который дает контроль над процессом линейной интерполяции и позволяет создавать плавные и адаптивные эффекты в анимациях, играх и других приложениях.<br>
<br>
>Линейная интерполяция широко используется в компьютерной графике, анимации, компьютерных играх, а также в обработке сигналов и цифровой обработке изображений. Например, при перемещении объекта от одной точки к другой на экране, линейная интерполяция может использоваться для плавного и равномерного изменения координат объекта по времени. Также линейная интерполяция может применяться для заполнения промежутков между известными значениями данных.
</details>
